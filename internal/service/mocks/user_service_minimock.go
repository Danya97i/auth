// Code generated by http://github.com/gojuno/minimock (v3.4.2). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Danya97i/auth/internal/service.UserService -o user_service_minimock.go -n UserServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/Danya97i/auth/internal/models"
	"github.com/gojuno/minimock/v3"
)

// UserServiceMock implements service.UserService
type UserServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateUser          func(ctx context.Context, userInfo models.UserInfo, pass string, passConfirm string) (i1 int64, err error)
	inspectFuncCreateUser   func(ctx context.Context, userInfo models.UserInfo, pass string, passConfirm string)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mUserServiceMockCreateUser

	funcDeleteUser          func(ctx context.Context, id int64) (err error)
	inspectFuncDeleteUser   func(ctx context.Context, id int64)
	afterDeleteUserCounter  uint64
	beforeDeleteUserCounter uint64
	DeleteUserMock          mUserServiceMockDeleteUser

	funcUpdateUser          func(ctx context.Context, id int64, userInfo *models.UserInfo) (err error)
	inspectFuncUpdateUser   func(ctx context.Context, id int64, userInfo *models.UserInfo)
	afterUpdateUserCounter  uint64
	beforeUpdateUserCounter uint64
	UpdateUserMock          mUserServiceMockUpdateUser

	funcUser          func(ctx context.Context, id int64) (up1 *models.User, err error)
	inspectFuncUser   func(ctx context.Context, id int64)
	afterUserCounter  uint64
	beforeUserCounter uint64
	UserMock          mUserServiceMockUser
}

// NewUserServiceMock returns a mock for service.UserService
func NewUserServiceMock(t minimock.Tester) *UserServiceMock {
	m := &UserServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateUserMock = mUserServiceMockCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*UserServiceMockCreateUserParams{}

	m.DeleteUserMock = mUserServiceMockDeleteUser{mock: m}
	m.DeleteUserMock.callArgs = []*UserServiceMockDeleteUserParams{}

	m.UpdateUserMock = mUserServiceMockUpdateUser{mock: m}
	m.UpdateUserMock.callArgs = []*UserServiceMockUpdateUserParams{}

	m.UserMock = mUserServiceMockUser{mock: m}
	m.UserMock.callArgs = []*UserServiceMockUserParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUserServiceMockCreateUser struct {
	optional           bool
	mock               *UserServiceMock
	defaultExpectation *UserServiceMockCreateUserExpectation
	expectations       []*UserServiceMockCreateUserExpectation

	callArgs []*UserServiceMockCreateUserParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UserServiceMockCreateUserExpectation specifies expectation struct of the UserService.CreateUser
type UserServiceMockCreateUserExpectation struct {
	mock      *UserServiceMock
	params    *UserServiceMockCreateUserParams
	paramPtrs *UserServiceMockCreateUserParamPtrs
	results   *UserServiceMockCreateUserResults
	Counter   uint64
}

// UserServiceMockCreateUserParams contains parameters of the UserService.CreateUser
type UserServiceMockCreateUserParams struct {
	ctx         context.Context
	userInfo    models.UserInfo
	pass        string
	passConfirm string
}

// UserServiceMockCreateUserParamPtrs contains pointers to parameters of the UserService.CreateUser
type UserServiceMockCreateUserParamPtrs struct {
	ctx         *context.Context
	userInfo    *models.UserInfo
	pass        *string
	passConfirm *string
}

// UserServiceMockCreateUserResults contains results of the UserService.CreateUser
type UserServiceMockCreateUserResults struct {
	i1  int64
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateUser *mUserServiceMockCreateUser) Optional() *mUserServiceMockCreateUser {
	mmCreateUser.optional = true
	return mmCreateUser
}

// Expect sets up expected params for UserService.CreateUser
func (mmCreateUser *mUserServiceMockCreateUser) Expect(ctx context.Context, userInfo models.UserInfo, pass string, passConfirm string) *mUserServiceMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserServiceMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserServiceMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.paramPtrs != nil {
		mmCreateUser.mock.t.Fatalf("UserServiceMock.CreateUser mock is already set by ExpectParams functions")
	}

	mmCreateUser.defaultExpectation.params = &UserServiceMockCreateUserParams{ctx, userInfo, pass, passConfirm}
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// ExpectCtxParam1 sets up expected param ctx for UserService.CreateUser
func (mmCreateUser *mUserServiceMockCreateUser) ExpectCtxParam1(ctx context.Context) *mUserServiceMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserServiceMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserServiceMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("UserServiceMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &UserServiceMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateUser
}

// ExpectUserInfoParam2 sets up expected param userInfo for UserService.CreateUser
func (mmCreateUser *mUserServiceMockCreateUser) ExpectUserInfoParam2(userInfo models.UserInfo) *mUserServiceMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserServiceMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserServiceMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("UserServiceMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &UserServiceMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.userInfo = &userInfo

	return mmCreateUser
}

// ExpectPassParam3 sets up expected param pass for UserService.CreateUser
func (mmCreateUser *mUserServiceMockCreateUser) ExpectPassParam3(pass string) *mUserServiceMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserServiceMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserServiceMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("UserServiceMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &UserServiceMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.pass = &pass

	return mmCreateUser
}

// ExpectPassConfirmParam4 sets up expected param passConfirm for UserService.CreateUser
func (mmCreateUser *mUserServiceMockCreateUser) ExpectPassConfirmParam4(passConfirm string) *mUserServiceMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserServiceMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserServiceMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("UserServiceMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &UserServiceMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.passConfirm = &passConfirm

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the UserService.CreateUser
func (mmCreateUser *mUserServiceMockCreateUser) Inspect(f func(ctx context.Context, userInfo models.UserInfo, pass string, passConfirm string)) *mUserServiceMockCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for UserServiceMock.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by UserService.CreateUser
func (mmCreateUser *mUserServiceMockCreateUser) Return(i1 int64, err error) *UserServiceMock {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserServiceMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserServiceMockCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &UserServiceMockCreateUserResults{i1, err}
	return mmCreateUser.mock
}

// Set uses given function f to mock the UserService.CreateUser method
func (mmCreateUser *mUserServiceMockCreateUser) Set(f func(ctx context.Context, userInfo models.UserInfo, pass string, passConfirm string) (i1 int64, err error)) *UserServiceMock {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the UserService.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the UserService.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	return mmCreateUser.mock
}

// When sets expectation for the UserService.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mUserServiceMockCreateUser) When(ctx context.Context, userInfo models.UserInfo, pass string, passConfirm string) *UserServiceMockCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserServiceMock.CreateUser mock is already set by Set")
	}

	expectation := &UserServiceMockCreateUserExpectation{
		mock:   mmCreateUser.mock,
		params: &UserServiceMockCreateUserParams{ctx, userInfo, pass, passConfirm},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up UserService.CreateUser return parameters for the expectation previously defined by the When method
func (e *UserServiceMockCreateUserExpectation) Then(i1 int64, err error) *UserServiceMock {
	e.results = &UserServiceMockCreateUserResults{i1, err}
	return e.mock
}

// Times sets number of times UserService.CreateUser should be invoked
func (mmCreateUser *mUserServiceMockCreateUser) Times(n uint64) *mUserServiceMockCreateUser {
	if n == 0 {
		mmCreateUser.mock.t.Fatalf("Times of UserServiceMock.CreateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateUser.expectedInvocations, n)
	return mmCreateUser
}

func (mmCreateUser *mUserServiceMockCreateUser) invocationsDone() bool {
	if len(mmCreateUser.expectations) == 0 && mmCreateUser.defaultExpectation == nil && mmCreateUser.mock.funcCreateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateUser.mock.afterCreateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateUser implements service.UserService
func (mmCreateUser *UserServiceMock) CreateUser(ctx context.Context, userInfo models.UserInfo, pass string, passConfirm string) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(ctx, userInfo, pass, passConfirm)
	}

	mm_params := UserServiceMockCreateUserParams{ctx, userInfo, pass, passConfirm}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, &mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_want_ptrs := mmCreateUser.CreateUserMock.defaultExpectation.paramPtrs

		mm_got := UserServiceMockCreateUserParams{ctx, userInfo, pass, passConfirm}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateUser.t.Errorf("UserServiceMock.CreateUser got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userInfo != nil && !minimock.Equal(*mm_want_ptrs.userInfo, mm_got.userInfo) {
				mmCreateUser.t.Errorf("UserServiceMock.CreateUser got unexpected parameter userInfo, want: %#v, got: %#v%s\n", *mm_want_ptrs.userInfo, mm_got.userInfo, minimock.Diff(*mm_want_ptrs.userInfo, mm_got.userInfo))
			}

			if mm_want_ptrs.pass != nil && !minimock.Equal(*mm_want_ptrs.pass, mm_got.pass) {
				mmCreateUser.t.Errorf("UserServiceMock.CreateUser got unexpected parameter pass, want: %#v, got: %#v%s\n", *mm_want_ptrs.pass, mm_got.pass, minimock.Diff(*mm_want_ptrs.pass, mm_got.pass))
			}

			if mm_want_ptrs.passConfirm != nil && !minimock.Equal(*mm_want_ptrs.passConfirm, mm_got.passConfirm) {
				mmCreateUser.t.Errorf("UserServiceMock.CreateUser got unexpected parameter passConfirm, want: %#v, got: %#v%s\n", *mm_want_ptrs.passConfirm, mm_got.passConfirm, minimock.Diff(*mm_want_ptrs.passConfirm, mm_got.passConfirm))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("UserServiceMock.CreateUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUser.t.Fatal("No results are set for the UserServiceMock.CreateUser")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(ctx, userInfo, pass, passConfirm)
	}
	mmCreateUser.t.Fatalf("Unexpected call to UserServiceMock.CreateUser. %v %v %v %v", ctx, userInfo, pass, passConfirm)
	return
}

// CreateUserAfterCounter returns a count of finished UserServiceMock.CreateUser invocations
func (mmCreateUser *UserServiceMock) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of UserServiceMock.CreateUser invocations
func (mmCreateUser *UserServiceMock) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to UserServiceMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mUserServiceMockCreateUser) Calls() []*UserServiceMockCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*UserServiceMockCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockCreateUserDone() bool {
	if m.CreateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateUserMock.invocationsDone()
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *UserServiceMock) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserServiceMock.CreateUser with params: %#v", *e.params)
		}
	}

	afterCreateUserCounter := mm_atomic.LoadUint64(&m.afterCreateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && afterCreateUserCounter < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserServiceMock.CreateUser")
		} else {
			m.t.Errorf("Expected call to UserServiceMock.CreateUser with params: %#v", *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && afterCreateUserCounter < 1 {
		m.t.Error("Expected call to UserServiceMock.CreateUser")
	}

	if !m.CreateUserMock.invocationsDone() && afterCreateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserServiceMock.CreateUser but found %d calls",
			mm_atomic.LoadUint64(&m.CreateUserMock.expectedInvocations), afterCreateUserCounter)
	}
}

type mUserServiceMockDeleteUser struct {
	optional           bool
	mock               *UserServiceMock
	defaultExpectation *UserServiceMockDeleteUserExpectation
	expectations       []*UserServiceMockDeleteUserExpectation

	callArgs []*UserServiceMockDeleteUserParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UserServiceMockDeleteUserExpectation specifies expectation struct of the UserService.DeleteUser
type UserServiceMockDeleteUserExpectation struct {
	mock      *UserServiceMock
	params    *UserServiceMockDeleteUserParams
	paramPtrs *UserServiceMockDeleteUserParamPtrs
	results   *UserServiceMockDeleteUserResults
	Counter   uint64
}

// UserServiceMockDeleteUserParams contains parameters of the UserService.DeleteUser
type UserServiceMockDeleteUserParams struct {
	ctx context.Context
	id  int64
}

// UserServiceMockDeleteUserParamPtrs contains pointers to parameters of the UserService.DeleteUser
type UserServiceMockDeleteUserParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// UserServiceMockDeleteUserResults contains results of the UserService.DeleteUser
type UserServiceMockDeleteUserResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteUser *mUserServiceMockDeleteUser) Optional() *mUserServiceMockDeleteUser {
	mmDeleteUser.optional = true
	return mmDeleteUser
}

// Expect sets up expected params for UserService.DeleteUser
func (mmDeleteUser *mUserServiceMockDeleteUser) Expect(ctx context.Context, id int64) *mUserServiceMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserServiceMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &UserServiceMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.paramPtrs != nil {
		mmDeleteUser.mock.t.Fatalf("UserServiceMock.DeleteUser mock is already set by ExpectParams functions")
	}

	mmDeleteUser.defaultExpectation.params = &UserServiceMockDeleteUserParams{ctx, id}
	for _, e := range mmDeleteUser.expectations {
		if minimock.Equal(e.params, mmDeleteUser.defaultExpectation.params) {
			mmDeleteUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteUser.defaultExpectation.params)
		}
	}

	return mmDeleteUser
}

// ExpectCtxParam1 sets up expected param ctx for UserService.DeleteUser
func (mmDeleteUser *mUserServiceMockDeleteUser) ExpectCtxParam1(ctx context.Context) *mUserServiceMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserServiceMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &UserServiceMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("UserServiceMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &UserServiceMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteUser
}

// ExpectIdParam2 sets up expected param id for UserService.DeleteUser
func (mmDeleteUser *mUserServiceMockDeleteUser) ExpectIdParam2(id int64) *mUserServiceMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserServiceMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &UserServiceMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("UserServiceMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &UserServiceMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.id = &id

	return mmDeleteUser
}

// Inspect accepts an inspector function that has same arguments as the UserService.DeleteUser
func (mmDeleteUser *mUserServiceMockDeleteUser) Inspect(f func(ctx context.Context, id int64)) *mUserServiceMockDeleteUser {
	if mmDeleteUser.mock.inspectFuncDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("Inspect function is already set for UserServiceMock.DeleteUser")
	}

	mmDeleteUser.mock.inspectFuncDeleteUser = f

	return mmDeleteUser
}

// Return sets up results that will be returned by UserService.DeleteUser
func (mmDeleteUser *mUserServiceMockDeleteUser) Return(err error) *UserServiceMock {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserServiceMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &UserServiceMockDeleteUserExpectation{mock: mmDeleteUser.mock}
	}
	mmDeleteUser.defaultExpectation.results = &UserServiceMockDeleteUserResults{err}
	return mmDeleteUser.mock
}

// Set uses given function f to mock the UserService.DeleteUser method
func (mmDeleteUser *mUserServiceMockDeleteUser) Set(f func(ctx context.Context, id int64) (err error)) *UserServiceMock {
	if mmDeleteUser.defaultExpectation != nil {
		mmDeleteUser.mock.t.Fatalf("Default expectation is already set for the UserService.DeleteUser method")
	}

	if len(mmDeleteUser.expectations) > 0 {
		mmDeleteUser.mock.t.Fatalf("Some expectations are already set for the UserService.DeleteUser method")
	}

	mmDeleteUser.mock.funcDeleteUser = f
	return mmDeleteUser.mock
}

// When sets expectation for the UserService.DeleteUser which will trigger the result defined by the following
// Then helper
func (mmDeleteUser *mUserServiceMockDeleteUser) When(ctx context.Context, id int64) *UserServiceMockDeleteUserExpectation {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserServiceMock.DeleteUser mock is already set by Set")
	}

	expectation := &UserServiceMockDeleteUserExpectation{
		mock:   mmDeleteUser.mock,
		params: &UserServiceMockDeleteUserParams{ctx, id},
	}
	mmDeleteUser.expectations = append(mmDeleteUser.expectations, expectation)
	return expectation
}

// Then sets up UserService.DeleteUser return parameters for the expectation previously defined by the When method
func (e *UserServiceMockDeleteUserExpectation) Then(err error) *UserServiceMock {
	e.results = &UserServiceMockDeleteUserResults{err}
	return e.mock
}

// Times sets number of times UserService.DeleteUser should be invoked
func (mmDeleteUser *mUserServiceMockDeleteUser) Times(n uint64) *mUserServiceMockDeleteUser {
	if n == 0 {
		mmDeleteUser.mock.t.Fatalf("Times of UserServiceMock.DeleteUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteUser.expectedInvocations, n)
	return mmDeleteUser
}

func (mmDeleteUser *mUserServiceMockDeleteUser) invocationsDone() bool {
	if len(mmDeleteUser.expectations) == 0 && mmDeleteUser.defaultExpectation == nil && mmDeleteUser.mock.funcDeleteUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteUser.mock.afterDeleteUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteUser implements service.UserService
func (mmDeleteUser *UserServiceMock) DeleteUser(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteUser.beforeDeleteUserCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteUser.afterDeleteUserCounter, 1)

	if mmDeleteUser.inspectFuncDeleteUser != nil {
		mmDeleteUser.inspectFuncDeleteUser(ctx, id)
	}

	mm_params := UserServiceMockDeleteUserParams{ctx, id}

	// Record call args
	mmDeleteUser.DeleteUserMock.mutex.Lock()
	mmDeleteUser.DeleteUserMock.callArgs = append(mmDeleteUser.DeleteUserMock.callArgs, &mm_params)
	mmDeleteUser.DeleteUserMock.mutex.Unlock()

	for _, e := range mmDeleteUser.DeleteUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteUser.DeleteUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteUser.DeleteUserMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteUser.DeleteUserMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteUser.DeleteUserMock.defaultExpectation.paramPtrs

		mm_got := UserServiceMockDeleteUserParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteUser.t.Errorf("UserServiceMock.DeleteUser got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteUser.t.Errorf("UserServiceMock.DeleteUser got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteUser.t.Errorf("UserServiceMock.DeleteUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteUser.DeleteUserMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteUser.t.Fatal("No results are set for the UserServiceMock.DeleteUser")
		}
		return (*mm_results).err
	}
	if mmDeleteUser.funcDeleteUser != nil {
		return mmDeleteUser.funcDeleteUser(ctx, id)
	}
	mmDeleteUser.t.Fatalf("Unexpected call to UserServiceMock.DeleteUser. %v %v", ctx, id)
	return
}

// DeleteUserAfterCounter returns a count of finished UserServiceMock.DeleteUser invocations
func (mmDeleteUser *UserServiceMock) DeleteUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.afterDeleteUserCounter)
}

// DeleteUserBeforeCounter returns a count of UserServiceMock.DeleteUser invocations
func (mmDeleteUser *UserServiceMock) DeleteUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.beforeDeleteUserCounter)
}

// Calls returns a list of arguments used in each call to UserServiceMock.DeleteUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteUser *mUserServiceMockDeleteUser) Calls() []*UserServiceMockDeleteUserParams {
	mmDeleteUser.mutex.RLock()

	argCopy := make([]*UserServiceMockDeleteUserParams, len(mmDeleteUser.callArgs))
	copy(argCopy, mmDeleteUser.callArgs)

	mmDeleteUser.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteUserDone returns true if the count of the DeleteUser invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockDeleteUserDone() bool {
	if m.DeleteUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteUserMock.invocationsDone()
}

// MinimockDeleteUserInspect logs each unmet expectation
func (m *UserServiceMock) MinimockDeleteUserInspect() {
	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserServiceMock.DeleteUser with params: %#v", *e.params)
		}
	}

	afterDeleteUserCounter := mm_atomic.LoadUint64(&m.afterDeleteUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserMock.defaultExpectation != nil && afterDeleteUserCounter < 1 {
		if m.DeleteUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserServiceMock.DeleteUser")
		} else {
			m.t.Errorf("Expected call to UserServiceMock.DeleteUser with params: %#v", *m.DeleteUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUser != nil && afterDeleteUserCounter < 1 {
		m.t.Error("Expected call to UserServiceMock.DeleteUser")
	}

	if !m.DeleteUserMock.invocationsDone() && afterDeleteUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserServiceMock.DeleteUser but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteUserMock.expectedInvocations), afterDeleteUserCounter)
	}
}

type mUserServiceMockUpdateUser struct {
	optional           bool
	mock               *UserServiceMock
	defaultExpectation *UserServiceMockUpdateUserExpectation
	expectations       []*UserServiceMockUpdateUserExpectation

	callArgs []*UserServiceMockUpdateUserParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UserServiceMockUpdateUserExpectation specifies expectation struct of the UserService.UpdateUser
type UserServiceMockUpdateUserExpectation struct {
	mock      *UserServiceMock
	params    *UserServiceMockUpdateUserParams
	paramPtrs *UserServiceMockUpdateUserParamPtrs
	results   *UserServiceMockUpdateUserResults
	Counter   uint64
}

// UserServiceMockUpdateUserParams contains parameters of the UserService.UpdateUser
type UserServiceMockUpdateUserParams struct {
	ctx      context.Context
	id       int64
	userInfo *models.UserInfo
}

// UserServiceMockUpdateUserParamPtrs contains pointers to parameters of the UserService.UpdateUser
type UserServiceMockUpdateUserParamPtrs struct {
	ctx      *context.Context
	id       *int64
	userInfo **models.UserInfo
}

// UserServiceMockUpdateUserResults contains results of the UserService.UpdateUser
type UserServiceMockUpdateUserResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateUser *mUserServiceMockUpdateUser) Optional() *mUserServiceMockUpdateUser {
	mmUpdateUser.optional = true
	return mmUpdateUser
}

// Expect sets up expected params for UserService.UpdateUser
func (mmUpdateUser *mUserServiceMockUpdateUser) Expect(ctx context.Context, id int64, userInfo *models.UserInfo) *mUserServiceMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserServiceMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UserServiceMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.paramPtrs != nil {
		mmUpdateUser.mock.t.Fatalf("UserServiceMock.UpdateUser mock is already set by ExpectParams functions")
	}

	mmUpdateUser.defaultExpectation.params = &UserServiceMockUpdateUserParams{ctx, id, userInfo}
	for _, e := range mmUpdateUser.expectations {
		if minimock.Equal(e.params, mmUpdateUser.defaultExpectation.params) {
			mmUpdateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateUser.defaultExpectation.params)
		}
	}

	return mmUpdateUser
}

// ExpectCtxParam1 sets up expected param ctx for UserService.UpdateUser
func (mmUpdateUser *mUserServiceMockUpdateUser) ExpectCtxParam1(ctx context.Context) *mUserServiceMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserServiceMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UserServiceMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("UserServiceMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &UserServiceMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateUser
}

// ExpectIdParam2 sets up expected param id for UserService.UpdateUser
func (mmUpdateUser *mUserServiceMockUpdateUser) ExpectIdParam2(id int64) *mUserServiceMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserServiceMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UserServiceMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("UserServiceMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &UserServiceMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.id = &id

	return mmUpdateUser
}

// ExpectUserInfoParam3 sets up expected param userInfo for UserService.UpdateUser
func (mmUpdateUser *mUserServiceMockUpdateUser) ExpectUserInfoParam3(userInfo *models.UserInfo) *mUserServiceMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserServiceMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UserServiceMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("UserServiceMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &UserServiceMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.userInfo = &userInfo

	return mmUpdateUser
}

// Inspect accepts an inspector function that has same arguments as the UserService.UpdateUser
func (mmUpdateUser *mUserServiceMockUpdateUser) Inspect(f func(ctx context.Context, id int64, userInfo *models.UserInfo)) *mUserServiceMockUpdateUser {
	if mmUpdateUser.mock.inspectFuncUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("Inspect function is already set for UserServiceMock.UpdateUser")
	}

	mmUpdateUser.mock.inspectFuncUpdateUser = f

	return mmUpdateUser
}

// Return sets up results that will be returned by UserService.UpdateUser
func (mmUpdateUser *mUserServiceMockUpdateUser) Return(err error) *UserServiceMock {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserServiceMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UserServiceMockUpdateUserExpectation{mock: mmUpdateUser.mock}
	}
	mmUpdateUser.defaultExpectation.results = &UserServiceMockUpdateUserResults{err}
	return mmUpdateUser.mock
}

// Set uses given function f to mock the UserService.UpdateUser method
func (mmUpdateUser *mUserServiceMockUpdateUser) Set(f func(ctx context.Context, id int64, userInfo *models.UserInfo) (err error)) *UserServiceMock {
	if mmUpdateUser.defaultExpectation != nil {
		mmUpdateUser.mock.t.Fatalf("Default expectation is already set for the UserService.UpdateUser method")
	}

	if len(mmUpdateUser.expectations) > 0 {
		mmUpdateUser.mock.t.Fatalf("Some expectations are already set for the UserService.UpdateUser method")
	}

	mmUpdateUser.mock.funcUpdateUser = f
	return mmUpdateUser.mock
}

// When sets expectation for the UserService.UpdateUser which will trigger the result defined by the following
// Then helper
func (mmUpdateUser *mUserServiceMockUpdateUser) When(ctx context.Context, id int64, userInfo *models.UserInfo) *UserServiceMockUpdateUserExpectation {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserServiceMock.UpdateUser mock is already set by Set")
	}

	expectation := &UserServiceMockUpdateUserExpectation{
		mock:   mmUpdateUser.mock,
		params: &UserServiceMockUpdateUserParams{ctx, id, userInfo},
	}
	mmUpdateUser.expectations = append(mmUpdateUser.expectations, expectation)
	return expectation
}

// Then sets up UserService.UpdateUser return parameters for the expectation previously defined by the When method
func (e *UserServiceMockUpdateUserExpectation) Then(err error) *UserServiceMock {
	e.results = &UserServiceMockUpdateUserResults{err}
	return e.mock
}

// Times sets number of times UserService.UpdateUser should be invoked
func (mmUpdateUser *mUserServiceMockUpdateUser) Times(n uint64) *mUserServiceMockUpdateUser {
	if n == 0 {
		mmUpdateUser.mock.t.Fatalf("Times of UserServiceMock.UpdateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateUser.expectedInvocations, n)
	return mmUpdateUser
}

func (mmUpdateUser *mUserServiceMockUpdateUser) invocationsDone() bool {
	if len(mmUpdateUser.expectations) == 0 && mmUpdateUser.defaultExpectation == nil && mmUpdateUser.mock.funcUpdateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateUser.mock.afterUpdateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateUser implements service.UserService
func (mmUpdateUser *UserServiceMock) UpdateUser(ctx context.Context, id int64, userInfo *models.UserInfo) (err error) {
	mm_atomic.AddUint64(&mmUpdateUser.beforeUpdateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateUser.afterUpdateUserCounter, 1)

	if mmUpdateUser.inspectFuncUpdateUser != nil {
		mmUpdateUser.inspectFuncUpdateUser(ctx, id, userInfo)
	}

	mm_params := UserServiceMockUpdateUserParams{ctx, id, userInfo}

	// Record call args
	mmUpdateUser.UpdateUserMock.mutex.Lock()
	mmUpdateUser.UpdateUserMock.callArgs = append(mmUpdateUser.UpdateUserMock.callArgs, &mm_params)
	mmUpdateUser.UpdateUserMock.mutex.Unlock()

	for _, e := range mmUpdateUser.UpdateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateUser.UpdateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateUser.UpdateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateUser.UpdateUserMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateUser.UpdateUserMock.defaultExpectation.paramPtrs

		mm_got := UserServiceMockUpdateUserParams{ctx, id, userInfo}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateUser.t.Errorf("UserServiceMock.UpdateUser got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdateUser.t.Errorf("UserServiceMock.UpdateUser got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.userInfo != nil && !minimock.Equal(*mm_want_ptrs.userInfo, mm_got.userInfo) {
				mmUpdateUser.t.Errorf("UserServiceMock.UpdateUser got unexpected parameter userInfo, want: %#v, got: %#v%s\n", *mm_want_ptrs.userInfo, mm_got.userInfo, minimock.Diff(*mm_want_ptrs.userInfo, mm_got.userInfo))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateUser.t.Errorf("UserServiceMock.UpdateUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateUser.UpdateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateUser.t.Fatal("No results are set for the UserServiceMock.UpdateUser")
		}
		return (*mm_results).err
	}
	if mmUpdateUser.funcUpdateUser != nil {
		return mmUpdateUser.funcUpdateUser(ctx, id, userInfo)
	}
	mmUpdateUser.t.Fatalf("Unexpected call to UserServiceMock.UpdateUser. %v %v %v", ctx, id, userInfo)
	return
}

// UpdateUserAfterCounter returns a count of finished UserServiceMock.UpdateUser invocations
func (mmUpdateUser *UserServiceMock) UpdateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.afterUpdateUserCounter)
}

// UpdateUserBeforeCounter returns a count of UserServiceMock.UpdateUser invocations
func (mmUpdateUser *UserServiceMock) UpdateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.beforeUpdateUserCounter)
}

// Calls returns a list of arguments used in each call to UserServiceMock.UpdateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateUser *mUserServiceMockUpdateUser) Calls() []*UserServiceMockUpdateUserParams {
	mmUpdateUser.mutex.RLock()

	argCopy := make([]*UserServiceMockUpdateUserParams, len(mmUpdateUser.callArgs))
	copy(argCopy, mmUpdateUser.callArgs)

	mmUpdateUser.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateUserDone returns true if the count of the UpdateUser invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockUpdateUserDone() bool {
	if m.UpdateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateUserMock.invocationsDone()
}

// MinimockUpdateUserInspect logs each unmet expectation
func (m *UserServiceMock) MinimockUpdateUserInspect() {
	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserServiceMock.UpdateUser with params: %#v", *e.params)
		}
	}

	afterUpdateUserCounter := mm_atomic.LoadUint64(&m.afterUpdateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserMock.defaultExpectation != nil && afterUpdateUserCounter < 1 {
		if m.UpdateUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserServiceMock.UpdateUser")
		} else {
			m.t.Errorf("Expected call to UserServiceMock.UpdateUser with params: %#v", *m.UpdateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUser != nil && afterUpdateUserCounter < 1 {
		m.t.Error("Expected call to UserServiceMock.UpdateUser")
	}

	if !m.UpdateUserMock.invocationsDone() && afterUpdateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserServiceMock.UpdateUser but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateUserMock.expectedInvocations), afterUpdateUserCounter)
	}
}

type mUserServiceMockUser struct {
	optional           bool
	mock               *UserServiceMock
	defaultExpectation *UserServiceMockUserExpectation
	expectations       []*UserServiceMockUserExpectation

	callArgs []*UserServiceMockUserParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UserServiceMockUserExpectation specifies expectation struct of the UserService.User
type UserServiceMockUserExpectation struct {
	mock      *UserServiceMock
	params    *UserServiceMockUserParams
	paramPtrs *UserServiceMockUserParamPtrs
	results   *UserServiceMockUserResults
	Counter   uint64
}

// UserServiceMockUserParams contains parameters of the UserService.User
type UserServiceMockUserParams struct {
	ctx context.Context
	id  int64
}

// UserServiceMockUserParamPtrs contains pointers to parameters of the UserService.User
type UserServiceMockUserParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// UserServiceMockUserResults contains results of the UserService.User
type UserServiceMockUserResults struct {
	up1 *models.User
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUser *mUserServiceMockUser) Optional() *mUserServiceMockUser {
	mmUser.optional = true
	return mmUser
}

// Expect sets up expected params for UserService.User
func (mmUser *mUserServiceMockUser) Expect(ctx context.Context, id int64) *mUserServiceMockUser {
	if mmUser.mock.funcUser != nil {
		mmUser.mock.t.Fatalf("UserServiceMock.User mock is already set by Set")
	}

	if mmUser.defaultExpectation == nil {
		mmUser.defaultExpectation = &UserServiceMockUserExpectation{}
	}

	if mmUser.defaultExpectation.paramPtrs != nil {
		mmUser.mock.t.Fatalf("UserServiceMock.User mock is already set by ExpectParams functions")
	}

	mmUser.defaultExpectation.params = &UserServiceMockUserParams{ctx, id}
	for _, e := range mmUser.expectations {
		if minimock.Equal(e.params, mmUser.defaultExpectation.params) {
			mmUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUser.defaultExpectation.params)
		}
	}

	return mmUser
}

// ExpectCtxParam1 sets up expected param ctx for UserService.User
func (mmUser *mUserServiceMockUser) ExpectCtxParam1(ctx context.Context) *mUserServiceMockUser {
	if mmUser.mock.funcUser != nil {
		mmUser.mock.t.Fatalf("UserServiceMock.User mock is already set by Set")
	}

	if mmUser.defaultExpectation == nil {
		mmUser.defaultExpectation = &UserServiceMockUserExpectation{}
	}

	if mmUser.defaultExpectation.params != nil {
		mmUser.mock.t.Fatalf("UserServiceMock.User mock is already set by Expect")
	}

	if mmUser.defaultExpectation.paramPtrs == nil {
		mmUser.defaultExpectation.paramPtrs = &UserServiceMockUserParamPtrs{}
	}
	mmUser.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUser
}

// ExpectIdParam2 sets up expected param id for UserService.User
func (mmUser *mUserServiceMockUser) ExpectIdParam2(id int64) *mUserServiceMockUser {
	if mmUser.mock.funcUser != nil {
		mmUser.mock.t.Fatalf("UserServiceMock.User mock is already set by Set")
	}

	if mmUser.defaultExpectation == nil {
		mmUser.defaultExpectation = &UserServiceMockUserExpectation{}
	}

	if mmUser.defaultExpectation.params != nil {
		mmUser.mock.t.Fatalf("UserServiceMock.User mock is already set by Expect")
	}

	if mmUser.defaultExpectation.paramPtrs == nil {
		mmUser.defaultExpectation.paramPtrs = &UserServiceMockUserParamPtrs{}
	}
	mmUser.defaultExpectation.paramPtrs.id = &id

	return mmUser
}

// Inspect accepts an inspector function that has same arguments as the UserService.User
func (mmUser *mUserServiceMockUser) Inspect(f func(ctx context.Context, id int64)) *mUserServiceMockUser {
	if mmUser.mock.inspectFuncUser != nil {
		mmUser.mock.t.Fatalf("Inspect function is already set for UserServiceMock.User")
	}

	mmUser.mock.inspectFuncUser = f

	return mmUser
}

// Return sets up results that will be returned by UserService.User
func (mmUser *mUserServiceMockUser) Return(up1 *models.User, err error) *UserServiceMock {
	if mmUser.mock.funcUser != nil {
		mmUser.mock.t.Fatalf("UserServiceMock.User mock is already set by Set")
	}

	if mmUser.defaultExpectation == nil {
		mmUser.defaultExpectation = &UserServiceMockUserExpectation{mock: mmUser.mock}
	}
	mmUser.defaultExpectation.results = &UserServiceMockUserResults{up1, err}
	return mmUser.mock
}

// Set uses given function f to mock the UserService.User method
func (mmUser *mUserServiceMockUser) Set(f func(ctx context.Context, id int64) (up1 *models.User, err error)) *UserServiceMock {
	if mmUser.defaultExpectation != nil {
		mmUser.mock.t.Fatalf("Default expectation is already set for the UserService.User method")
	}

	if len(mmUser.expectations) > 0 {
		mmUser.mock.t.Fatalf("Some expectations are already set for the UserService.User method")
	}

	mmUser.mock.funcUser = f
	return mmUser.mock
}

// When sets expectation for the UserService.User which will trigger the result defined by the following
// Then helper
func (mmUser *mUserServiceMockUser) When(ctx context.Context, id int64) *UserServiceMockUserExpectation {
	if mmUser.mock.funcUser != nil {
		mmUser.mock.t.Fatalf("UserServiceMock.User mock is already set by Set")
	}

	expectation := &UserServiceMockUserExpectation{
		mock:   mmUser.mock,
		params: &UserServiceMockUserParams{ctx, id},
	}
	mmUser.expectations = append(mmUser.expectations, expectation)
	return expectation
}

// Then sets up UserService.User return parameters for the expectation previously defined by the When method
func (e *UserServiceMockUserExpectation) Then(up1 *models.User, err error) *UserServiceMock {
	e.results = &UserServiceMockUserResults{up1, err}
	return e.mock
}

// Times sets number of times UserService.User should be invoked
func (mmUser *mUserServiceMockUser) Times(n uint64) *mUserServiceMockUser {
	if n == 0 {
		mmUser.mock.t.Fatalf("Times of UserServiceMock.User mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUser.expectedInvocations, n)
	return mmUser
}

func (mmUser *mUserServiceMockUser) invocationsDone() bool {
	if len(mmUser.expectations) == 0 && mmUser.defaultExpectation == nil && mmUser.mock.funcUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUser.mock.afterUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// User implements service.UserService
func (mmUser *UserServiceMock) User(ctx context.Context, id int64) (up1 *models.User, err error) {
	mm_atomic.AddUint64(&mmUser.beforeUserCounter, 1)
	defer mm_atomic.AddUint64(&mmUser.afterUserCounter, 1)

	if mmUser.inspectFuncUser != nil {
		mmUser.inspectFuncUser(ctx, id)
	}

	mm_params := UserServiceMockUserParams{ctx, id}

	// Record call args
	mmUser.UserMock.mutex.Lock()
	mmUser.UserMock.callArgs = append(mmUser.UserMock.callArgs, &mm_params)
	mmUser.UserMock.mutex.Unlock()

	for _, e := range mmUser.UserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmUser.UserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUser.UserMock.defaultExpectation.Counter, 1)
		mm_want := mmUser.UserMock.defaultExpectation.params
		mm_want_ptrs := mmUser.UserMock.defaultExpectation.paramPtrs

		mm_got := UserServiceMockUserParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUser.t.Errorf("UserServiceMock.User got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUser.t.Errorf("UserServiceMock.User got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUser.t.Errorf("UserServiceMock.User got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUser.UserMock.defaultExpectation.results
		if mm_results == nil {
			mmUser.t.Fatal("No results are set for the UserServiceMock.User")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmUser.funcUser != nil {
		return mmUser.funcUser(ctx, id)
	}
	mmUser.t.Fatalf("Unexpected call to UserServiceMock.User. %v %v", ctx, id)
	return
}

// UserAfterCounter returns a count of finished UserServiceMock.User invocations
func (mmUser *UserServiceMock) UserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUser.afterUserCounter)
}

// UserBeforeCounter returns a count of UserServiceMock.User invocations
func (mmUser *UserServiceMock) UserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUser.beforeUserCounter)
}

// Calls returns a list of arguments used in each call to UserServiceMock.User.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUser *mUserServiceMockUser) Calls() []*UserServiceMockUserParams {
	mmUser.mutex.RLock()

	argCopy := make([]*UserServiceMockUserParams, len(mmUser.callArgs))
	copy(argCopy, mmUser.callArgs)

	mmUser.mutex.RUnlock()

	return argCopy
}

// MinimockUserDone returns true if the count of the User invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockUserDone() bool {
	if m.UserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UserMock.invocationsDone()
}

// MinimockUserInspect logs each unmet expectation
func (m *UserServiceMock) MinimockUserInspect() {
	for _, e := range m.UserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserServiceMock.User with params: %#v", *e.params)
		}
	}

	afterUserCounter := mm_atomic.LoadUint64(&m.afterUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UserMock.defaultExpectation != nil && afterUserCounter < 1 {
		if m.UserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserServiceMock.User")
		} else {
			m.t.Errorf("Expected call to UserServiceMock.User with params: %#v", *m.UserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUser != nil && afterUserCounter < 1 {
		m.t.Error("Expected call to UserServiceMock.User")
	}

	if !m.UserMock.invocationsDone() && afterUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserServiceMock.User but found %d calls",
			mm_atomic.LoadUint64(&m.UserMock.expectedInvocations), afterUserCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateUserInspect()

			m.MinimockDeleteUserInspect()

			m.MinimockUpdateUserInspect()

			m.MinimockUserInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateUserDone() &&
		m.MinimockDeleteUserDone() &&
		m.MinimockUpdateUserDone() &&
		m.MinimockUserDone()
}
