// Code generated by http://github.com/gojuno/minimock (v3.4.2). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Danya97i/auth/internal/repository.UserRepository -o user_repository_minimock.go -n UserRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/Danya97i/auth/internal/models"
	"github.com/gojuno/minimock/v3"
)

// UserRepositoryMock implements repository.UserRepository
type UserRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, userInfo models.UserInfo, passHash string) (i1 int64, err error)
	inspectFuncCreate   func(ctx context.Context, userInfo models.UserInfo, passHash string)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mUserRepositoryMockCreate

	funcDelete          func(ctx context.Context, id int64) (err error)
	inspectFuncDelete   func(ctx context.Context, id int64)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mUserRepositoryMockDelete

	funcUpdate          func(ctx context.Context, id int64, user models.UserInfo) (err error)
	inspectFuncUpdate   func(ctx context.Context, id int64, user models.UserInfo)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mUserRepositoryMockUpdate

	funcUser          func(ctx context.Context, id int64) (up1 *models.User, err error)
	inspectFuncUser   func(ctx context.Context, id int64)
	afterUserCounter  uint64
	beforeUserCounter uint64
	UserMock          mUserRepositoryMockUser
}

// NewUserRepositoryMock returns a mock for repository.UserRepository
func NewUserRepositoryMock(t minimock.Tester) *UserRepositoryMock {
	m := &UserRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mUserRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*UserRepositoryMockCreateParams{}

	m.DeleteMock = mUserRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*UserRepositoryMockDeleteParams{}

	m.UpdateMock = mUserRepositoryMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*UserRepositoryMockUpdateParams{}

	m.UserMock = mUserRepositoryMockUser{mock: m}
	m.UserMock.callArgs = []*UserRepositoryMockUserParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUserRepositoryMockCreate struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockCreateExpectation
	expectations       []*UserRepositoryMockCreateExpectation

	callArgs []*UserRepositoryMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UserRepositoryMockCreateExpectation specifies expectation struct of the UserRepository.Create
type UserRepositoryMockCreateExpectation struct {
	mock      *UserRepositoryMock
	params    *UserRepositoryMockCreateParams
	paramPtrs *UserRepositoryMockCreateParamPtrs
	results   *UserRepositoryMockCreateResults
	Counter   uint64
}

// UserRepositoryMockCreateParams contains parameters of the UserRepository.Create
type UserRepositoryMockCreateParams struct {
	ctx      context.Context
	userInfo models.UserInfo
	passHash string
}

// UserRepositoryMockCreateParamPtrs contains pointers to parameters of the UserRepository.Create
type UserRepositoryMockCreateParamPtrs struct {
	ctx      *context.Context
	userInfo *models.UserInfo
	passHash *string
}

// UserRepositoryMockCreateResults contains results of the UserRepository.Create
type UserRepositoryMockCreateResults struct {
	i1  int64
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mUserRepositoryMockCreate) Optional() *mUserRepositoryMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for UserRepository.Create
func (mmCreate *mUserRepositoryMockCreate) Expect(ctx context.Context, userInfo models.UserInfo, passHash string) *mUserRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UserRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &UserRepositoryMockCreateParams{ctx, userInfo, passHash}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.Create
func (mmCreate *mUserRepositoryMockCreate) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UserRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &UserRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreate
}

// ExpectUserInfoParam2 sets up expected param userInfo for UserRepository.Create
func (mmCreate *mUserRepositoryMockCreate) ExpectUserInfoParam2(userInfo models.UserInfo) *mUserRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UserRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &UserRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.userInfo = &userInfo

	return mmCreate
}

// ExpectPassHashParam3 sets up expected param passHash for UserRepository.Create
func (mmCreate *mUserRepositoryMockCreate) ExpectPassHashParam3(passHash string) *mUserRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UserRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &UserRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.passHash = &passHash

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.Create
func (mmCreate *mUserRepositoryMockCreate) Inspect(f func(ctx context.Context, userInfo models.UserInfo, passHash string)) *mUserRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by UserRepository.Create
func (mmCreate *mUserRepositoryMockCreate) Return(i1 int64, err error) *UserRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UserRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &UserRepositoryMockCreateResults{i1, err}
	return mmCreate.mock
}

// Set uses given function f to mock the UserRepository.Create method
func (mmCreate *mUserRepositoryMockCreate) Set(f func(ctx context.Context, userInfo models.UserInfo, passHash string) (i1 int64, err error)) *UserRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the UserRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the UserRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the UserRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mUserRepositoryMockCreate) When(ctx context.Context, userInfo models.UserInfo, passHash string) *UserRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Set")
	}

	expectation := &UserRepositoryMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &UserRepositoryMockCreateParams{ctx, userInfo, passHash},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.Create return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockCreateExpectation) Then(i1 int64, err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockCreateResults{i1, err}
	return e.mock
}

// Times sets number of times UserRepository.Create should be invoked
func (mmCreate *mUserRepositoryMockCreate) Times(n uint64) *mUserRepositoryMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of UserRepositoryMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	return mmCreate
}

func (mmCreate *mUserRepositoryMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements repository.UserRepository
func (mmCreate *UserRepositoryMock) Create(ctx context.Context, userInfo models.UserInfo, passHash string) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, userInfo, passHash)
	}

	mm_params := UserRepositoryMockCreateParams{ctx, userInfo, passHash}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockCreateParams{ctx, userInfo, passHash}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("UserRepositoryMock.Create got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userInfo != nil && !minimock.Equal(*mm_want_ptrs.userInfo, mm_got.userInfo) {
				mmCreate.t.Errorf("UserRepositoryMock.Create got unexpected parameter userInfo, want: %#v, got: %#v%s\n", *mm_want_ptrs.userInfo, mm_got.userInfo, minimock.Diff(*mm_want_ptrs.userInfo, mm_got.userInfo))
			}

			if mm_want_ptrs.passHash != nil && !minimock.Equal(*mm_want_ptrs.passHash, mm_got.passHash) {
				mmCreate.t.Errorf("UserRepositoryMock.Create got unexpected parameter passHash, want: %#v, got: %#v%s\n", *mm_want_ptrs.passHash, mm_got.passHash, minimock.Diff(*mm_want_ptrs.passHash, mm_got.passHash))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("UserRepositoryMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the UserRepositoryMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, userInfo, passHash)
	}
	mmCreate.t.Fatalf("Unexpected call to UserRepositoryMock.Create. %v %v %v", ctx, userInfo, passHash)
	return
}

// CreateAfterCounter returns a count of finished UserRepositoryMock.Create invocations
func (mmCreate *UserRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of UserRepositoryMock.Create invocations
func (mmCreate *UserRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mUserRepositoryMockCreate) Calls() []*UserRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*UserRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.Create with params: %#v", *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserRepositoryMock.Create")
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Error("Expected call to UserRepositoryMock.Create")
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.Create but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), afterCreateCounter)
	}
}

type mUserRepositoryMockDelete struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockDeleteExpectation
	expectations       []*UserRepositoryMockDeleteExpectation

	callArgs []*UserRepositoryMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UserRepositoryMockDeleteExpectation specifies expectation struct of the UserRepository.Delete
type UserRepositoryMockDeleteExpectation struct {
	mock      *UserRepositoryMock
	params    *UserRepositoryMockDeleteParams
	paramPtrs *UserRepositoryMockDeleteParamPtrs
	results   *UserRepositoryMockDeleteResults
	Counter   uint64
}

// UserRepositoryMockDeleteParams contains parameters of the UserRepository.Delete
type UserRepositoryMockDeleteParams struct {
	ctx context.Context
	id  int64
}

// UserRepositoryMockDeleteParamPtrs contains pointers to parameters of the UserRepository.Delete
type UserRepositoryMockDeleteParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// UserRepositoryMockDeleteResults contains results of the UserRepository.Delete
type UserRepositoryMockDeleteResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mUserRepositoryMockDelete) Optional() *mUserRepositoryMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for UserRepository.Delete
func (mmDelete *mUserRepositoryMockDelete) Expect(ctx context.Context, id int64) *mUserRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &UserRepositoryMockDeleteParams{ctx, id}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.Delete
func (mmDelete *mUserRepositoryMockDelete) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &UserRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDelete
}

// ExpectIdParam2 sets up expected param id for UserRepository.Delete
func (mmDelete *mUserRepositoryMockDelete) ExpectIdParam2(id int64) *mUserRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &UserRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.id = &id

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.Delete
func (mmDelete *mUserRepositoryMockDelete) Inspect(f func(ctx context.Context, id int64)) *mUserRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by UserRepository.Delete
func (mmDelete *mUserRepositoryMockDelete) Return(err error) *UserRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &UserRepositoryMockDeleteResults{err}
	return mmDelete.mock
}

// Set uses given function f to mock the UserRepository.Delete method
func (mmDelete *mUserRepositoryMockDelete) Set(f func(ctx context.Context, id int64) (err error)) *UserRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the UserRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the UserRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the UserRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mUserRepositoryMockDelete) When(ctx context.Context, id int64) *UserRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &UserRepositoryMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &UserRepositoryMockDeleteParams{ctx, id},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.Delete return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockDeleteExpectation) Then(err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockDeleteResults{err}
	return e.mock
}

// Times sets number of times UserRepository.Delete should be invoked
func (mmDelete *mUserRepositoryMockDelete) Times(n uint64) *mUserRepositoryMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of UserRepositoryMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	return mmDelete
}

func (mmDelete *mUserRepositoryMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements repository.UserRepository
func (mmDelete *UserRepositoryMock) Delete(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id)
	}

	mm_params := UserRepositoryMockDeleteParams{ctx, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockDeleteParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("UserRepositoryMock.Delete got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDelete.t.Errorf("UserRepositoryMock.Delete got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("UserRepositoryMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the UserRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id)
	}
	mmDelete.t.Fatalf("Unexpected call to UserRepositoryMock.Delete. %v %v", ctx, id)
	return
}

// DeleteAfterCounter returns a count of finished UserRepositoryMock.Delete invocations
func (mmDelete *UserRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of UserRepositoryMock.Delete invocations
func (mmDelete *UserRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mUserRepositoryMockDelete) Calls() []*UserRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*UserRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.Delete with params: %#v", *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserRepositoryMock.Delete")
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Error("Expected call to UserRepositoryMock.Delete")
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.Delete but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), afterDeleteCounter)
	}
}

type mUserRepositoryMockUpdate struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockUpdateExpectation
	expectations       []*UserRepositoryMockUpdateExpectation

	callArgs []*UserRepositoryMockUpdateParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UserRepositoryMockUpdateExpectation specifies expectation struct of the UserRepository.Update
type UserRepositoryMockUpdateExpectation struct {
	mock      *UserRepositoryMock
	params    *UserRepositoryMockUpdateParams
	paramPtrs *UserRepositoryMockUpdateParamPtrs
	results   *UserRepositoryMockUpdateResults
	Counter   uint64
}

// UserRepositoryMockUpdateParams contains parameters of the UserRepository.Update
type UserRepositoryMockUpdateParams struct {
	ctx  context.Context
	id   int64
	user models.UserInfo
}

// UserRepositoryMockUpdateParamPtrs contains pointers to parameters of the UserRepository.Update
type UserRepositoryMockUpdateParamPtrs struct {
	ctx  *context.Context
	id   *int64
	user *models.UserInfo
}

// UserRepositoryMockUpdateResults contains results of the UserRepository.Update
type UserRepositoryMockUpdateResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mUserRepositoryMockUpdate) Optional() *mUserRepositoryMockUpdate {
	mmUpdate.optional = true
	return mmUpdate
}

// Expect sets up expected params for UserRepository.Update
func (mmUpdate *mUserRepositoryMockUpdate) Expect(ctx context.Context, id int64, user models.UserInfo) *mUserRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &UserRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.paramPtrs != nil {
		mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by ExpectParams functions")
	}

	mmUpdate.defaultExpectation.params = &UserRepositoryMockUpdateParams{ctx, id, user}
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.Update
func (mmUpdate *mUserRepositoryMockUpdate) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &UserRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &UserRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdate
}

// ExpectIdParam2 sets up expected param id for UserRepository.Update
func (mmUpdate *mUserRepositoryMockUpdate) ExpectIdParam2(id int64) *mUserRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &UserRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &UserRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.id = &id

	return mmUpdate
}

// ExpectUserParam3 sets up expected param user for UserRepository.Update
func (mmUpdate *mUserRepositoryMockUpdate) ExpectUserParam3(user models.UserInfo) *mUserRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &UserRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &UserRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.user = &user

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.Update
func (mmUpdate *mUserRepositoryMockUpdate) Inspect(f func(ctx context.Context, id int64, user models.UserInfo)) *mUserRepositoryMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by UserRepository.Update
func (mmUpdate *mUserRepositoryMockUpdate) Return(err error) *UserRepositoryMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &UserRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &UserRepositoryMockUpdateResults{err}
	return mmUpdate.mock
}

// Set uses given function f to mock the UserRepository.Update method
func (mmUpdate *mUserRepositoryMockUpdate) Set(f func(ctx context.Context, id int64, user models.UserInfo) (err error)) *UserRepositoryMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the UserRepository.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the UserRepository.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	return mmUpdate.mock
}

// When sets expectation for the UserRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mUserRepositoryMockUpdate) When(ctx context.Context, id int64, user models.UserInfo) *UserRepositoryMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Set")
	}

	expectation := &UserRepositoryMockUpdateExpectation{
		mock:   mmUpdate.mock,
		params: &UserRepositoryMockUpdateParams{ctx, id, user},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.Update return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockUpdateExpectation) Then(err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockUpdateResults{err}
	return e.mock
}

// Times sets number of times UserRepository.Update should be invoked
func (mmUpdate *mUserRepositoryMockUpdate) Times(n uint64) *mUserRepositoryMockUpdate {
	if n == 0 {
		mmUpdate.mock.t.Fatalf("Times of UserRepositoryMock.Update mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdate.expectedInvocations, n)
	return mmUpdate
}

func (mmUpdate *mUserRepositoryMockUpdate) invocationsDone() bool {
	if len(mmUpdate.expectations) == 0 && mmUpdate.defaultExpectation == nil && mmUpdate.mock.funcUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdate.mock.afterUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Update implements repository.UserRepository
func (mmUpdate *UserRepositoryMock) Update(ctx context.Context, id int64, user models.UserInfo) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, id, user)
	}

	mm_params := UserRepositoryMockUpdateParams{ctx, id, user}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockUpdateParams{ctx, id, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdate.t.Errorf("UserRepositoryMock.Update got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdate.t.Errorf("UserRepositoryMock.Update got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmUpdate.t.Errorf("UserRepositoryMock.Update got unexpected parameter user, want: %#v, got: %#v%s\n", *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("UserRepositoryMock.Update got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the UserRepositoryMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, id, user)
	}
	mmUpdate.t.Fatalf("Unexpected call to UserRepositoryMock.Update. %v %v %v", ctx, id, user)
	return
}

// UpdateAfterCounter returns a count of finished UserRepositoryMock.Update invocations
func (mmUpdate *UserRepositoryMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of UserRepositoryMock.Update invocations
func (mmUpdate *UserRepositoryMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mUserRepositoryMockUpdate) Calls() []*UserRepositoryMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*UserRepositoryMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockUpdateDone() bool {
	if m.UpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMock.invocationsDone()
}

// MinimockUpdateInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.Update with params: %#v", *e.params)
		}
	}

	afterUpdateCounter := mm_atomic.LoadUint64(&m.afterUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && afterUpdateCounter < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserRepositoryMock.Update")
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.Update with params: %#v", *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && afterUpdateCounter < 1 {
		m.t.Error("Expected call to UserRepositoryMock.Update")
	}

	if !m.UpdateMock.invocationsDone() && afterUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.Update but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMock.expectedInvocations), afterUpdateCounter)
	}
}

type mUserRepositoryMockUser struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockUserExpectation
	expectations       []*UserRepositoryMockUserExpectation

	callArgs []*UserRepositoryMockUserParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UserRepositoryMockUserExpectation specifies expectation struct of the UserRepository.User
type UserRepositoryMockUserExpectation struct {
	mock      *UserRepositoryMock
	params    *UserRepositoryMockUserParams
	paramPtrs *UserRepositoryMockUserParamPtrs
	results   *UserRepositoryMockUserResults
	Counter   uint64
}

// UserRepositoryMockUserParams contains parameters of the UserRepository.User
type UserRepositoryMockUserParams struct {
	ctx context.Context
	id  int64
}

// UserRepositoryMockUserParamPtrs contains pointers to parameters of the UserRepository.User
type UserRepositoryMockUserParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// UserRepositoryMockUserResults contains results of the UserRepository.User
type UserRepositoryMockUserResults struct {
	up1 *models.User
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUser *mUserRepositoryMockUser) Optional() *mUserRepositoryMockUser {
	mmUser.optional = true
	return mmUser
}

// Expect sets up expected params for UserRepository.User
func (mmUser *mUserRepositoryMockUser) Expect(ctx context.Context, id int64) *mUserRepositoryMockUser {
	if mmUser.mock.funcUser != nil {
		mmUser.mock.t.Fatalf("UserRepositoryMock.User mock is already set by Set")
	}

	if mmUser.defaultExpectation == nil {
		mmUser.defaultExpectation = &UserRepositoryMockUserExpectation{}
	}

	if mmUser.defaultExpectation.paramPtrs != nil {
		mmUser.mock.t.Fatalf("UserRepositoryMock.User mock is already set by ExpectParams functions")
	}

	mmUser.defaultExpectation.params = &UserRepositoryMockUserParams{ctx, id}
	for _, e := range mmUser.expectations {
		if minimock.Equal(e.params, mmUser.defaultExpectation.params) {
			mmUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUser.defaultExpectation.params)
		}
	}

	return mmUser
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.User
func (mmUser *mUserRepositoryMockUser) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockUser {
	if mmUser.mock.funcUser != nil {
		mmUser.mock.t.Fatalf("UserRepositoryMock.User mock is already set by Set")
	}

	if mmUser.defaultExpectation == nil {
		mmUser.defaultExpectation = &UserRepositoryMockUserExpectation{}
	}

	if mmUser.defaultExpectation.params != nil {
		mmUser.mock.t.Fatalf("UserRepositoryMock.User mock is already set by Expect")
	}

	if mmUser.defaultExpectation.paramPtrs == nil {
		mmUser.defaultExpectation.paramPtrs = &UserRepositoryMockUserParamPtrs{}
	}
	mmUser.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUser
}

// ExpectIdParam2 sets up expected param id for UserRepository.User
func (mmUser *mUserRepositoryMockUser) ExpectIdParam2(id int64) *mUserRepositoryMockUser {
	if mmUser.mock.funcUser != nil {
		mmUser.mock.t.Fatalf("UserRepositoryMock.User mock is already set by Set")
	}

	if mmUser.defaultExpectation == nil {
		mmUser.defaultExpectation = &UserRepositoryMockUserExpectation{}
	}

	if mmUser.defaultExpectation.params != nil {
		mmUser.mock.t.Fatalf("UserRepositoryMock.User mock is already set by Expect")
	}

	if mmUser.defaultExpectation.paramPtrs == nil {
		mmUser.defaultExpectation.paramPtrs = &UserRepositoryMockUserParamPtrs{}
	}
	mmUser.defaultExpectation.paramPtrs.id = &id

	return mmUser
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.User
func (mmUser *mUserRepositoryMockUser) Inspect(f func(ctx context.Context, id int64)) *mUserRepositoryMockUser {
	if mmUser.mock.inspectFuncUser != nil {
		mmUser.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.User")
	}

	mmUser.mock.inspectFuncUser = f

	return mmUser
}

// Return sets up results that will be returned by UserRepository.User
func (mmUser *mUserRepositoryMockUser) Return(up1 *models.User, err error) *UserRepositoryMock {
	if mmUser.mock.funcUser != nil {
		mmUser.mock.t.Fatalf("UserRepositoryMock.User mock is already set by Set")
	}

	if mmUser.defaultExpectation == nil {
		mmUser.defaultExpectation = &UserRepositoryMockUserExpectation{mock: mmUser.mock}
	}
	mmUser.defaultExpectation.results = &UserRepositoryMockUserResults{up1, err}
	return mmUser.mock
}

// Set uses given function f to mock the UserRepository.User method
func (mmUser *mUserRepositoryMockUser) Set(f func(ctx context.Context, id int64) (up1 *models.User, err error)) *UserRepositoryMock {
	if mmUser.defaultExpectation != nil {
		mmUser.mock.t.Fatalf("Default expectation is already set for the UserRepository.User method")
	}

	if len(mmUser.expectations) > 0 {
		mmUser.mock.t.Fatalf("Some expectations are already set for the UserRepository.User method")
	}

	mmUser.mock.funcUser = f
	return mmUser.mock
}

// When sets expectation for the UserRepository.User which will trigger the result defined by the following
// Then helper
func (mmUser *mUserRepositoryMockUser) When(ctx context.Context, id int64) *UserRepositoryMockUserExpectation {
	if mmUser.mock.funcUser != nil {
		mmUser.mock.t.Fatalf("UserRepositoryMock.User mock is already set by Set")
	}

	expectation := &UserRepositoryMockUserExpectation{
		mock:   mmUser.mock,
		params: &UserRepositoryMockUserParams{ctx, id},
	}
	mmUser.expectations = append(mmUser.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.User return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockUserExpectation) Then(up1 *models.User, err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockUserResults{up1, err}
	return e.mock
}

// Times sets number of times UserRepository.User should be invoked
func (mmUser *mUserRepositoryMockUser) Times(n uint64) *mUserRepositoryMockUser {
	if n == 0 {
		mmUser.mock.t.Fatalf("Times of UserRepositoryMock.User mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUser.expectedInvocations, n)
	return mmUser
}

func (mmUser *mUserRepositoryMockUser) invocationsDone() bool {
	if len(mmUser.expectations) == 0 && mmUser.defaultExpectation == nil && mmUser.mock.funcUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUser.mock.afterUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// User implements repository.UserRepository
func (mmUser *UserRepositoryMock) User(ctx context.Context, id int64) (up1 *models.User, err error) {
	mm_atomic.AddUint64(&mmUser.beforeUserCounter, 1)
	defer mm_atomic.AddUint64(&mmUser.afterUserCounter, 1)

	if mmUser.inspectFuncUser != nil {
		mmUser.inspectFuncUser(ctx, id)
	}

	mm_params := UserRepositoryMockUserParams{ctx, id}

	// Record call args
	mmUser.UserMock.mutex.Lock()
	mmUser.UserMock.callArgs = append(mmUser.UserMock.callArgs, &mm_params)
	mmUser.UserMock.mutex.Unlock()

	for _, e := range mmUser.UserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmUser.UserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUser.UserMock.defaultExpectation.Counter, 1)
		mm_want := mmUser.UserMock.defaultExpectation.params
		mm_want_ptrs := mmUser.UserMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockUserParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUser.t.Errorf("UserRepositoryMock.User got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUser.t.Errorf("UserRepositoryMock.User got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUser.t.Errorf("UserRepositoryMock.User got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUser.UserMock.defaultExpectation.results
		if mm_results == nil {
			mmUser.t.Fatal("No results are set for the UserRepositoryMock.User")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmUser.funcUser != nil {
		return mmUser.funcUser(ctx, id)
	}
	mmUser.t.Fatalf("Unexpected call to UserRepositoryMock.User. %v %v", ctx, id)
	return
}

// UserAfterCounter returns a count of finished UserRepositoryMock.User invocations
func (mmUser *UserRepositoryMock) UserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUser.afterUserCounter)
}

// UserBeforeCounter returns a count of UserRepositoryMock.User invocations
func (mmUser *UserRepositoryMock) UserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUser.beforeUserCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.User.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUser *mUserRepositoryMockUser) Calls() []*UserRepositoryMockUserParams {
	mmUser.mutex.RLock()

	argCopy := make([]*UserRepositoryMockUserParams, len(mmUser.callArgs))
	copy(argCopy, mmUser.callArgs)

	mmUser.mutex.RUnlock()

	return argCopy
}

// MinimockUserDone returns true if the count of the User invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockUserDone() bool {
	if m.UserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UserMock.invocationsDone()
}

// MinimockUserInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockUserInspect() {
	for _, e := range m.UserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.User with params: %#v", *e.params)
		}
	}

	afterUserCounter := mm_atomic.LoadUint64(&m.afterUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UserMock.defaultExpectation != nil && afterUserCounter < 1 {
		if m.UserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserRepositoryMock.User")
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.User with params: %#v", *m.UserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUser != nil && afterUserCounter < 1 {
		m.t.Error("Expected call to UserRepositoryMock.User")
	}

	if !m.UserMock.invocationsDone() && afterUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.User but found %d calls",
			mm_atomic.LoadUint64(&m.UserMock.expectedInvocations), afterUserCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()

			m.MinimockUpdateInspect()

			m.MinimockUserInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockUpdateDone() &&
		m.MinimockUserDone()
}
